# project-4
do your best to optimize SM3 implementation (software)
SM3的软件优化实现
# 实验原理
# SM3算法介绍

杂凑值算法也可称为摘要算法或者哈希算法。通过对数据资料的填充、分组、扩展压缩等方式计算成特定长度的数值，来作为数据指纹或者数据特征使用。常见的MD5算法长度为128bit（16字节），SHA1算法计算长度为160bit（20字节），SHA256算法计算长度256bit（32字节），SHA512算法计算长度512bit（64字节），SM3算法计算长度为256bit（32字节）。

SM3密码杂凑值算法是国家密码局公布的自研算法，是在SHA-256基础上改进实现的一种算法，其安全性和SHA-256相当，参见国家密码局2010年12月《SM3密码杂凑算法》。其分组长度为512bit，最终计算长度为256bit（32字节）。该算法于2012年发布为密码行业标准(GM/T 0004-2012)，2016年发布为国家密码杂凑算法标准(GB/T32905-2016)。

# SM3算法流程

## 初始化

需要定义8个32bit长的容器或者寄存器V[8]，初始值赋值为一个IV值。

## 数据填充

进行数据填充的目的主要是为了数据分组压缩，计算SM3哈希值的数据有可能是文件、也可能是字符串，长度大小不一。SM3是以512bit为一组来进行计算的，只要长度满512bit即可进行一次压缩计算，到最后剩余字符不足512bit部分就需要进行填充。

假设消息m的长度为l比特。数据填充的具体步骤如下：

1.  首先将比特“1”添加到消息的末尾。
2.  再添加k个“0”，k是满足的最小的非负整数。
3.  再添加一个64位比特串，该比特串是长度l的二进制表示。

## 迭代压缩

迭代压缩主要是针对每个分组进行的，分组大小为512bit（即64字节）的data。在迭代压缩过程中还会对data进行数据扩展，既填充到不同的32bit的临时变量中，然后通过异或、循环左移等操作进行数据计算，最终更新到V[8]中。每一个分组计算完成之后，都会更新V[8]。等最后一个填充分组也进行迭代压缩之后，V[8]寄存器或者数组中的值就是本次数据计算的杂凑值。

1.  **消息扩展**

将消息分组按以下方法扩展成132个字，用于压缩函数CF：

1.  将消息分组划分为16个字。
2.  *FOR j=16 to 67:*
3.  *FOR j=0 to 63：*
    1.  **压缩函数**

令A,B,C,D,E,F,G,H为字寄存器，SS1,SS2,TT1,TT2为中间变量，压缩函数为。计算过程如下：

*FOR j=0 to 63:*

1.  **迭代过程**
2.  将填充后的消息m按512比特进行分组：，其中*n=(l+k+65)/512*。
3.  对m按下列方式迭代：

*FOR i=0 to n-1:*

其中CF是压缩函数，位256比特初始值IV，位填充后的消息分组，迭代压缩结果位。

# 实现方式
SM3适用于商用密码应用中的数字签名和验证，是在SHA-256基础上改进实现的一种算法，其安全性和SHA-256相当。 SM3和MD5的迭代过程类似，也采用Merkle-Damgard结构。消息分组长度为512位，摘要值长度为256位。
整个算法的执行过程可以概括成四个步骤：消息填充、消息扩展、迭代压缩、输出结果。

由于其M-D结构，SM3无法利用多线程将消息分组同时加密，因为前者的结果会在后面形成依赖。于是采用多线程多次加密不同文件，并且循环展开关键步骤、然后同时调用多个SM3模块进行多线程优化，提高吞吐量。
### 1.unroll

现代 CPU 采用流水线设计 (可以类比汽车生产流水线，分多阶段)，把一条机器指令的执行分成多个阶段，然后每个时钟周期尽可能多地执行不同指令的不同阶段，为了让流水线更好地流懂，我们可以在写程序时可以地减少程序相邻行的数据相关，于是我们通过循环展开即增加每次迭代计算元素的数量，减少循环迭代次数，更好地增加指令的并行性（虽然这是牺牲了代码的可读性和循环中灵活性判断的结果）效果如图所示:
![图片](https://github.com/jlwdfq/project-4/assets/129512207/45829615-5187-4fab-a28c-3b634de40d4c)


###  2.muti-thread
采用多个线程，每个线程完成多次sm3，计算多次加密不同文件，然后同时调用多个SM3模块进行多线程优化，能够达到提高吞吐量的效果。
### 3.预计算
预计算64个常量并存储。优化后，虽然会牺牲256字节的存储空间，但可以避免每个消息分组都去进行常数的移位操作。且运算时间几乎是和消息大小成正比的，消息越大，优化效果越明显，即缩短的运算时间就越多，性价比越高。

# 实验结果 
### 优化前结果
![image](https://github.com/jlwdfq/project-4/assets/129512207/f8aeec93-8c4b-4253-adc8-268991da29f6)




### 优化后结果

![image](https://github.com/jlwdfq/project-4/assets/129512207/f8e1a3d8-8834-4d73-a483-2ac0d15de3de)

# 实验环境
| 语言  | 系统      | 平台   | 处理器                     |
|-------|-----------|--------|----------------------------|
| Cpp   | Windows10 | VS2022 | Intel(R) Core(TM)i7-11800H |
# 小组分工
戴方奇 202100460092 单人组完成project4

